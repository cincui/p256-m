#!/usr/bin/python3
# coding: utf-8

"""Generate test data for P-256 and related functions."""

from p256 import ModInt, p256, ecdsa_modint_from_hash

base = 2**32
n_limbs = 8
top = base ** n_limbs


def montmul(x, y, m):
    """Montgomery multiplication of x, y mod m."""
    x = ModInt(x, m)
    y = ModInt(y, m)
    R = ModInt(top, m)
    return int(x * y / R)


Rp = ModInt(top, p256.p)
Rn = ModInt(top, p256.n)


def get(x, i):
    """Return i-th limb of x."""
    return (x // base**i) % base


def c_print(name, val):
    """Print 256-bit value as little-endian array of 32-bit values."""
    print('static const uint32_t', name + '[8] = {', end='')
    for i in range(8):
        sep = '\n    ' if i % 4 == 0 else ' '
        print(sep + '0x' + format(get(val, i), '08x') + ',', end='')
    print('\n};')


def c_bytes(name, val, n):
    """Print value as big-endian array of n bytes."""
    array = name + '[' + str(n) + ']'
    print('static const uint8_t', array, '= {', end='')
    for i in range(n):
        sep = '\n    ' if i % 8 == 0 else ' '
        limb = (val // 256**(n-1-i)) % 256
        print(sep + '0x' + format(limb, '02x') + ',', end='')
    print('\n};')


def c_point(name, p):
    """Print curve point as array of bytes."""
    val = top * int(p.x()) + int(p.y())
    c_bytes(name, val, 64)


def c_hex(name, hex_str):
    """Print hex string as array of bytes."""
    n = len(hex_str) // 2
    v = int(hex_str, 16)
    c_bytes(name, v, n)


def c_pair(name, r, s):
    """Print a pair of 256-bit values as an array of 64 bytes."""
    val = top * r + s
    c_bytes(name, val, 64)


def print_e(name, h):
    """Print the e value (Montgomery domain) derive from hash h."""
    e = ecdsa_modint_from_hash(bytes.fromhex(h), p256.n, 256)
    e_mont = int(e) * top % p256.n
    c_print(name, e_mont)


def print_val(name, x, y, m):
    """Print result of Montgomery multiplication."""
    v = montmul(x, y, m)
    c_print(name, v)


def com(msg):
    """Skip a line an print a comment."""
    print("\n/*", msg, "*/")


# These constants are not in test data but in the code itself
# This is how they were generated for reference.
#
# c_print("p256_b", int(p256.b * Rp))
# c_print("p256_Gx", int(p256.gx * Rp))
# c_print("p256_Gy", int(p256.gy * Rp))

print("""
/*
 * Test data for ECDH, ECDSA, and internal functions.
 * This file was generated by gen-test-data.py
 */
""")

# generated by random.randrange(2**256)
r = 0x760cd745ec0db49cf76db5ed0a14613ed937cbcb9c4ecc3c7d3d0eb8dcd1d063
s = 0x17380bcf120eb6d7dde65249accbcfffb3b1c6ed5444fc98c5e403b2514595c2

com("General-purpose random values")
c_print('r', r)
c_print('s', s)

com("r+s, r-s, s-r")
c_print('rps', r + s)
c_print('rms', r - s)
c_print('smr', s - r)

com("Useful values for arithmetic tests""")
c_print('zero', 0)
c_print('one', 1)
c_print('word', 2**32 - 1)
c_print('b128', 2**128)

com("n + 2**32 - 1 mod p")
c_print('npwmp', (p256.n + 2**32 - 1) % p256.p)
com("n + 2**128 mod p")
c_print('npbmp', (p256.n + 2**128) % p256.p)
com("n + n mod p")
c_print('npnmp', (p256.n * 2) % p256.p)
com("p - 1")
c_print('pm1', p256.p - 1)

com("r * 2^256 mod p and mod n")
c_print('rmontp', int(r * Rp))
c_print('rmontn', int(r * Rn))

com("r * s / 2^256 mod p")
print_val("rsRip", r, s, p256.p)
com("r * s / 2^256 mod n")
print_val("rsRin", r, s, p256.n)

com("r * s mod p")
c_print("rtsmp", r * s % p256.p)
com("r * s mod n")
c_print("rtsmn", r * s % p256.n)

com("r^-1 mod p")
c_print("rip", int(ModInt(r, p256.p).inv()))
com("r^-1 mod n")
c_print("rin", int(ModInt(r, p256.n).inv()))

com("actual curve parameters (not in Montgomery domain)")
c_print("b_raw", int(p256.b))
c_print("gx_raw", int(p256.gx))
c_print("gy_raw", int(p256.gy))

com("some jacobian coordinates for the base point, in Montgomery domain")
z = ModInt(r*s, p256.p)
c_print("jac_gx", int(p256.gx * z**2 * Rp))
c_print("jac_gy", int(p256.gy * z**3 * Rp))
c_print("jac_gz", int(z * Rp))

com("affine coordinates (not Montgomery) for 2 * G")
g2 = 2 * p256.base_point()
c_print("g2x", int(g2.x()))
c_print("g2y", int(g2.y()))

com("affine coordinates (not Montgomery) for 3 * G")
g3 = 3 * p256.base_point()
c_print("g3x", int(g3.x()))
c_print("g3y", int(g3.y()))

com("affine (non-Montgomery) y coordinates for -G, -2G, -3G")
c_print("g1yn", int(-p256.base_point().y()))
c_print("g2yn", int(-g2.y()))
c_print("g3yn", int(-g3.y()))

com("affine (non-Montgomery) coordinates for rG, sG, and rsG")
rg = r * p256.base_point()
sg = s * p256.base_point()
rsg = r * s * p256.base_point()
c_print("rgx", int(rg.x()))
c_print("rgy", int(rg.y()))
c_print("sgx", int(sg.x()))
c_print("sgy", int(sg.y()))
c_print("rsgx", int(rsg.x()))
c_print("rsgy", int(rsg.y()))

com("r and s as bytes, big-endian")
c_bytes("rbytes", r, 32)
c_bytes("sbytes", s, 32)

com("the curve's base point as bytes")
c_point('gbytes', p256.base_point())

com("rG, sG and rsG as bytes")
c_point("rgb", rg)
c_point("sgb", sg)
c_bytes("rsgxb", int(rsg.x()), 32)

# excerpt from RFC 6979 A.2.5, message = "sample" (6 bytes)
h1 = "8151325dcdbae9e0ff95f9f9658432dbedfdb209"
h256 = "af2bdbe1aa9b6ec1e2ade1d694f41fc71a831d0268e9891562113d8a62add1bf"
h512 = ("39a5e04aaff7455d9850c605364f514c11324ce64016960d23d5dc57d3ffd8f4"
        + "9a739468ab8049bf18eef820cdb1ad6c9015f838556bc7fad4138b23fdf986c7")

k1 = 0x882905F1227FD620FBF2ABF21244F0BA83D0DC3A9103DBBEE43A1FB858109DB4
r1 = 0x61340C88C3AAEBEB4F6D667F672CA9759A6CCAA9FA8811313039EE4A35471D32
s1 = 0x6D7F147DAC089441BB2E2FE8F7A3FA264B9C475098FDCF6E00D7C996E1B8B7EB

k256 = 0xA6E3C57DD01ABE90086538398355DD4C3B17AA873382B0F24D6129493D8AAD60
r256 = 0xEFD48B2AACB6A8FD1140DD9CD45E81D69D2C877B56AAF991C34D0EA84EAF3716
s256 = 0xF7CB1C942D657C41D436C7A1B6E29F65F3E900DBB9AFF4064DC4AB2F843ACDA8

k512 = 0x5FA81C63109BADB88C1F367B47DA606DA28CAD69AA22C4FE6AD7DF73A7173AA5
r512 = 0x8496A60B5E9B47C825488827E0495B0E3FA109EC4568FD3F8D1097678EB97F00
s512 = 0x2362AB1ADBE2B8ADF9CB9EDAB740EA6049C028114F2460F96554F61FAE3302FE

com("hashes from RFC 6979 A.2.5 and their derived integer")
c_hex("h1", h1)
c_hex("h256", h256)
c_hex("h512", h512)
print_e("h1_e", h1)
print_e("h256_e", h256)
print_e("h512_e", h512)

com("signature data from RFC 6979 A.2.5")
c_bytes("k1", k1, 32)
c_pair("sig1", r1, s1)
c_bytes("k256", k256, 32)
c_pair("sig256", r256, s256)
c_bytes("k512", k512, 32)
c_pair("sig512", r512, s512)

# key material from RFC 6979 A.2.5
x = 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721
Ux = 0x60FED4BA255A9D31C961EB74C6356D68C049B8923B61FA6CE669622E60F29FB6
Uy = 0x7903FE1008B8BC99A41AE9E95628BC64F2F1B20C2D7E9F5177A3C294D4462299

com("key material from RFC A.2.5")
c_bytes("ecdsa_priv", x, 32)
c_pair("ecdsa_pub", Ux, Uy)
